generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ADMIN (solo tú)
model Admin {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  password  String   // hasheado
  name      String
  createdAt DateTime @default(now())
}

// RESTAURANTES (tus clientes)
model Restaurant {
  id          Int      @id @default(autoincrement())
  slug        String   @unique // elysrestobar
  name        String   // Elys Restobar
  description String?
  logo        String?
  banner      String?
  
  // Contacto
  phone       String
  whatsapp    String   // Para enviar pedidos
  email       String?
  address     String?
  
  // Configuración
  isActive    Boolean  @default(true)
  currency    String   @default("ARS")
  colors      Json?    // {primary: "#FF6B35", secondary: "#004E89"}
  
  // Delivery
  deliveryCost     Float?
  minOrderAmount   Float?
  deliveryTime     String?  // "30-45 min"
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relaciones
  categories  Category[]
  products    Product[]
  orders      Order[]
  customers   Customer[]
}

// CATEGORÍAS
model Category {
  id            Int      @id @default(autoincrement())
  restaurantId  Int
  name          String   // "Pizzas"
  slug          String   // "pizzas"
  description   String?
  image         String?
  order         Int      @default(0) // Para ordenar en el menú
  isActive      Boolean  @default(true)
  
  restaurant    Restaurant @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  subcategories Subcategory[]
  products      Product[]
  
  @@unique([restaurantId, slug])
}

// SUBCATEGORÍAS (opcional)
model Subcategory {
  id          Int      @id @default(autoincrement())
  categoryId  Int
  name        String   // "Napolitanas"
  slug        String   // "napolitanas"
  order       Int      @default(0)
  isActive    Boolean  @default(true)
  
  category    Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  products    Product[]
  
  @@unique([categoryId, slug])
}

// PRODUCTOS
model Product {
  id             Int      @id @default(autoincrement())
  restaurantId   Int
  categoryId     Int
  subcategoryId  Int?
  
  name           String
  slug           String
  description    String?
  image          String?
  
  price          Float
  comparePrice   Float?   // Precio tachado (para mostrar descuento)
  
  // Disponibilidad
  isActive       Boolean  @default(true)
  isAvailable    Boolean  @default(true)
  stock          Int?     // null = ilimitado
  
  // Opciones (JSON)
  // {extras: [{name: "Extra queso", price: 200}], sizes: [{name: "Grande", price: 1500}]}
  options        Json?
  
  order          Int      @default(0)
  
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  
  restaurant     Restaurant   @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  category       Category     @relation(fields: [categoryId], references: [id])
  subcategory    Subcategory? @relation(fields: [subcategoryId], references: [id])
  orderItems     OrderItem[]
  
  @@unique([restaurantId, slug])
}

// CLIENTES (consumidores finales - opcional, para historial)
model Customer {
  id            Int      @id @default(autoincrement())
  restaurantId  Int
  
  name          String
  phone         String
  email         String?
  address       String?
  
  // Sistema de puntos (futuro)
  points        Int      @default(0)
  totalOrders   Int      @default(0)
  totalSpent    Float    @default(0)
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  restaurant    Restaurant @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  orders        Order[]
  
  @@unique([restaurantId, phone])
}

// PEDIDOS
model Order {
  id            Int      @id @default(autoincrement())
  restaurantId  Int
  customerId    Int?     // Opcional si quieres guardar historial
  
  // Datos del cliente (siempre guardamos por si acaso)
  customerName  String
  customerPhone String
  customerEmail String?
  
  // Entrega
  deliveryType  String   // "delivery" | "pickup" | "table"
  address       String?
  tableNumber   String?
  
  // Detalles del pedido
  items         OrderItem[]
  subtotal      Float
  deliveryCost  Float    @default(0)
  discount      Float    @default(0)
  total         Float
  
  // Estado
  status        String   @default("pending") 
  // pending -> confirmed -> preparing -> ready -> delivered -> cancelled
  
  // Pago
  paymentMethod String?  // "cash" | "card" | "transfer"
  isPaid        Boolean  @default(false)
  
  // Notas
  notes         String?
  
  // WhatsApp
  whatsappSent  Boolean  @default(false)
  whatsappSentAt DateTime?
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  restaurant    Restaurant @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  customer      Customer?  @relation(fields: [customerId], references: [id])
}

// ITEMS DEL PEDIDO
model OrderItem {
  id          Int     @id @default(autoincrement())
  orderId     Int
  productId   Int
  
  name        String  // Guardamos el nombre por si el producto se borra
  price       Float   // Precio al momento del pedido
  quantity    Int
  
  // Opciones seleccionadas (JSON)
  // {size: "Grande", extras: ["Extra queso", "Doble pepperoni"]}
  options     Json?
  
  subtotal    Float   // price * quantity + opciones
  
  order       Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product     Product @relation(fields: [productId], references: [id])
}

// PROMOCIONES (futuro)
model Promotion {
  id            Int      @id @default(autoincrement())
  restaurantId  Int
  name          String
  description   String?
  code          String?  @unique
  
  discountType  String   // "percentage" | "fixed" | "product"
  discountValue Float
  
  minAmount     Float?
  maxDiscount   Float?
  
  isActive      Boolean  @default(true)
  startDate     DateTime?
  endDate       DateTime?
  
  createdAt     DateTime @default(now())
}